<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>House Price Prediction Model</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%);
            background-size: 20px 20px;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateX(-20px) translateY(-20px); }
            100% { transform: translateX(20px) translateY(20px); }
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .section:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-3px);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #666;
            font-size: 0.9em;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .prediction-form {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .data-preview {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            max-height: 400px;
            overflow: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .data-table th, .data-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè† House Price Prediction Model</h1>
            <p>Upload your dataset and train a machine learning model to predict house prices</p>
        </div>

        <div class="main-content">
            <!-- File Upload Section -->
            <div class="section">
                <h2>üìä Upload Dataset</h2>
                <div class="upload-area" id="uploadArea">
                    <div style="font-size: 3em; margin-bottom: 15px;">üìÅ</div>
                    <p><strong>Drop your CSV file here</strong></p>
                    <p>or click to browse</p>
                    <input type="file" id="fileInput" class="file-input" accept=".csv">
                </div>
                <div id="uploadStatus"></div>
            </div>

            <!-- Data Preview Section -->
            <div class="section hidden" id="dataPreviewSection">
                <h2>üëÄ Data Preview</h2>
                <div id="dataInfo"></div>
                <div class="data-preview">
                    <div id="dataTable"></div>
                </div>
            </div>

            <!-- Model Training Section -->
            <div class="section hidden" id="trainingSection">
                <h2>ü§ñ Train Model</h2>
                <p>Configure your model settings and train the prediction model</p>
                <div style="margin-top: 15px;">
                    <label for="testSize">Test Size (%):</label>
                    <input type="range" id="testSize" min="10" max="40" value="20" style="width: 200px; margin: 0 10px;">
                    <span id="testSizeValue">20%</span>
                </div>
                <button class="btn" id="trainBtn" style="margin-top: 15px;">üöÄ Train Model</button>
                
                <div class="loading" id="loadingIndicator">
                    <div class="loading-spinner"></div>
                    <p>Training model... Please wait</p>
                </div>
            </div>

            <!-- Results Section -->
            <div class="section hidden" id="resultsSection">
                <h2>üìà Model Performance</h2>
                <div class="grid">
                    <div class="metric-card">
                        <div class="metric-value" id="r2Score">-</div>
                        <div class="metric-label">R¬≤ Score</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="rmseValue">-</div>
                        <div class="metric-label">RMSE</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="mseValue">-</div>
                        <div class="metric-label">MSE</div>
                    </div>
                </div>

                <div class="chart-container">
                    <h3>Actual vs Predicted Prices</h3>
                    <canvas id="scatterChart" width="400" height="300"></canvas>
                </div>
            </div>

            <!-- Prediction Section -->
            <div class="section hidden" id="predictionSection">
                <h2>üîÆ Make Predictions</h2>
                <div class="prediction-form">
                    <div id="predictionInputs"></div>
                    <button class="btn" id="predictBtn" style="margin-top: 15px;">üí∞ Predict Price</button>
                    <div id="predictionResult" style="margin-top: 15px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class HousePricePredictor {
            constructor() {
                this.data = null;
                this.model = null;
                this.features = null;
                this.scaler = { mean: {}, std: {} };
                this.preprocessedData = null;
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const trainBtn = document.getElementById('trainBtn');
                const predictBtn = document.getElementById('predictBtn');
                const testSizeSlider = document.getElementById('testSize');

                // File upload events
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Training event
                trainBtn.addEventListener('click', this.trainModel.bind(this));
                
                // Prediction event
                predictBtn.addEventListener('click', this.makePrediction.bind(this));

                // Test size slider
                testSizeSlider.addEventListener('input', (e) => {
                    document.getElementById('testSizeValue').textContent = e.target.value + '%';
                });
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }

            handleFileSelect(e) {
                if (e.target.files.length > 0) {
                    this.processFile(e.target.files[0]);
                }
            }

            processFile(file) {
                if (!file.name.endsWith('.csv')) {
                    this.showStatus('Please upload a CSV file', 'error');
                    return;
                }

                this.showStatus('Loading dataset...', 'info');

                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            this.showStatus('Error parsing CSV: ' + results.errors[0].message, 'error');
                            return;
                        }

                        this.data = results.data;
                        this.showStatus(`Dataset loaded successfully! ${this.data.length} rows, ${Object.keys(this.data[0]).length} columns`, 'success');
                        this.showDataPreview();
                        this.preprocessData();
                    }
                });
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('uploadStatus');
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
            }

            showDataPreview() {
                const section = document.getElementById('dataPreviewSection');
                const infoDiv = document.getElementById('dataInfo');
                const tableDiv = document.getElementById('dataTable');

                section.classList.remove('hidden');

                // Show basic info
                const numericCols = Object.keys(this.data[0]).filter(col => 
                    typeof this.data[0][col] === 'number'
                ).length;
                const categoricalCols = Object.keys(this.data[0]).length - numericCols;

                infoDiv.innerHTML = `
                    <p><strong>Rows:</strong> ${this.data.length}</p>
                    <p><strong>Columns:</strong> ${Object.keys(this.data[0]).length}</p>
                    <p><strong>Numeric columns:</strong> ${numericCols}</p>
                    <p><strong>Categorical columns:</strong> ${categoricalCols}</p>
                `;

                // Show first 5 rows
                const headers = Object.keys(this.data[0]);
                const preview = this.data.slice(0, 5);

                let tableHTML = '<table class="data-table"><thead><tr>';
                headers.forEach(header => {
                    tableHTML += `<th>${header}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';

                preview.forEach(row => {
                    tableHTML += '<tr>';
                    headers.forEach(header => {
                        let value = row[header];
                        if (value === null || value === undefined) value = 'N/A';
                        if (typeof value === 'number') value = value.toFixed(2);
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });

                tableHTML += '</tbody></table>';
                tableDiv.innerHTML = tableHTML;
            }

            preprocessData() {
                if (!this.data || this.data.length === 0) return;

                // Check if SalePrice column exists
                if (!this.data[0].hasOwnProperty('SalePrice')) {
                    this.showStatus('Dataset must contain a "SalePrice" column', 'error');
                    return;
                }

                this.showStatus('Preprocessing data...', 'info');

                // Create a copy for preprocessing
                let processedData = JSON.parse(JSON.stringify(this.data));

                // Handle missing values and convert types
                const columns = Object.keys(processedData[0]);
                
                columns.forEach(col => {
                    const values = processedData.map(row => row[col]).filter(val => val !== null && val !== undefined && val !== '');
                    
                    if (values.length === 0) return;

                    // Determine if column is numeric or categorical
                    const isNumeric = values.every(val => !isNaN(val) && isFinite(val));

                    if (isNumeric) {
                        // Fill missing numeric values with mean
                        const mean = values.reduce((a, b) => a + Number(b), 0) / values.length;
                        processedData.forEach(row => {
                            if (row[col] === null || row[col] === undefined || row[col] === '') {
                                row[col] = mean;
                            }
                            row[col] = Number(row[col]);
                        });
                    } else {
                        // Fill missing categorical values with mode
                        const counts = {};
                        values.forEach(val => counts[val] = (counts[val] || 0) + 1);
                        const mode = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                        
                        processedData.forEach(row => {
                            if (row[col] === null || row[col] === undefined || row[col] === '') {
                                row[col] = mode;
                            }
                        });

                        // One-hot encode categorical variables
                        const uniqueValues = [...new Set(values)];
                        if (uniqueValues.length > 1 && uniqueValues.length <= 20) { // Limit categories
                            uniqueValues.slice(1).forEach(val => { // Drop first to avoid dummy trap
                                const newColName = `${col}_${val}`;
                                processedData.forEach(row => {
                                    row[newColName] = row[col] === val ? 1 : 0;
                                });
                            });
                        }
                        
                        // Remove original categorical column
                        processedData.forEach(row => delete row[col]);
                    }
                });

                this.preprocessedData = processedData;
                
                // Show training section
                document.getElementById('trainingSection').classList.remove('hidden');
                this.showStatus('Data preprocessed successfully!', 'success');
            }

            async trainModel() {
                if (!this.preprocessedData) {
                    this.showStatus('Please upload and preprocess data first', 'error');
                    return;
                }

                const loadingDiv = document.getElementById('loadingIndicator');
                const trainBtn = document.getElementById('trainBtn');
                
                loadingDiv.style.display = 'block';
                trainBtn.disabled = true;

                try {
                    // Prepare features and target
                    const features = Object.keys(this.preprocessedData[0]).filter(col => col !== 'SalePrice');
                    const X = this.preprocessedData.map(row => features.map(col => row[col]));
                    const y = this.preprocessedData.map(row => row['SalePrice']);

                    // Store feature names for prediction
                    this.features = features;

                    // Normalize features
                    this.normalizeFeatures(X);

                    // Split data
                    const testSize = document.getElementById('testSize').value / 100;
                    const splitIndex = Math.floor(X.length * (1 - testSize));
                    
                    const X_train = X.slice(0, splitIndex);
                    const X_test = X.slice(splitIndex);
                    const y_train = y.slice(0, splitIndex);
                    const y_test = y.slice(splitIndex);

                    // Train linear regression model
                    this.model = await this.trainLinearRegression(X_train, y_train);

                    // Make predictions
                    const y_pred = X_test.map(x => this.predict(x));

                    // Calculate metrics
                    const mse = this.calculateMSE(y_test, y_pred);
                    const rmse = Math.sqrt(mse);
                    const r2 = this.calculateR2(y_test, y_pred);

                    // Display results
                    this.displayResults(mse, rmse, r2, y_test, y_pred);
                    this.createPredictionForm();

                } catch (error) {
                    this.showStatus('Error training model: ' + error.message, 'error');
                } finally {
                    loadingDiv.style.display = 'none';
                    trainBtn.disabled = false;
                }
            }

            normalizeFeatures(X) {
                const numFeatures = X[0].length;
                
                for (let j = 0; j < numFeatures; j++) {
                    const column = X.map(row => row[j]);
                    const mean = column.reduce((a, b) => a + b, 0) / column.length;
                    const std = Math.sqrt(column.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / column.length);
                    
                    this.scaler.mean[j] = mean;
                    this.scaler.std[j] = std || 1; // Avoid division by zero

                    // Normalize
                    for (let i = 0; i < X.length; i++) {
                        X[i][j] = (X[i][j] - mean) / this.scaler.std[j];
                    }
                }
            }

            async trainLinearRegression(X, y) {
                // Simple gradient descent implementation
                const numFeatures = X[0].length;
                let weights = new Array(numFeatures).fill(0);
                let bias = 0;
                const learningRate = 0.01;
                const epochs = 1000;

                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalError = 0;
                    const gradients = new Array(numFeatures).fill(0);
                    let biasGradient = 0;

                    // Calculate gradients
                    for (let i = 0; i < X.length; i++) {
                        const prediction = this.dotProduct(X[i], weights) + bias;
                        const error = prediction - y[i];
                        totalError += error * error;

                        // Update gradients
                        for (let j = 0; j < numFeatures; j++) {
                            gradients[j] += error * X[i][j];
                        }
                        biasGradient += error;
                    }

                    // Update weights and bias
                    for (let j = 0; j < numFeatures; j++) {
                        weights[j] -= learningRate * gradients[j] / X.length;
                    }
                    bias -= learningRate * biasGradient / X.length;

                    // Add small delay to show training progress
                    if (epoch % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                return { weights, bias };
            }

            dotProduct(a, b) {
                return a.reduce((sum, val, i) => sum + val * b[i], 0);
            }

            predict(features) {
                if (!this.model) return 0;
                
                // Normalize features
                const normalizedFeatures = features.map((val, i) => {
                    const mean = this.scaler.mean[i] || 0;
                    const std = this.scaler.std[i] || 1;
                    return (val - mean) / std;
                });

                return this.dotProduct(normalizedFeatures, this.model.weights) + this.model.bias;
            }

            calculateMSE(actual, predicted) {
                const n = actual.length;
                return actual.reduce((sum, val, i) => sum + Math.pow(val - predicted[i], 2), 0) / n;
            }

            calculateR2(actual, predicted) {
                const yMean = actual.reduce((a, b) => a + b, 0) / actual.length;
                const totalSumSquares = actual.reduce((sum, val) => sum + Math.pow(val - yMean, 2), 0);
                const residualSumSquares = actual.reduce((sum, val, i) => sum + Math.pow(val - predicted[i], 2), 0);
                return 1 - (residualSumSquares / totalSumSquares);
            }

            displayResults(mse, rmse, r2, yTest, yPred) {
                // Update metric cards
                document.getElementById('r2Score').textContent = r2.toFixed(3);
                document.getElementById('rmseValue').textContent = rmse.toLocaleString();
                document.getElementById('mseValue').textContent = mse.toLocaleString();

                // Show results section
                document.getElementById('resultsSection').classList.remove('hidden');

                // Create scatter plot
                this.createScatterPlot(yTest, yPred);

                // Show prediction section
                document.getElementById('predictionSection').classList.remove('hidden');
            }

            createScatterPlot(actual, predicted) {
                const ctx = document.getElementById('scatterChart').getContext('2d');
                
                const data = actual.map((val, i) => ({
                    x: val,
                    y: predicted[i]
                }));

                new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Actual vs Predicted',
                            data: data,
                            backgroundColor: 'rgba(102, 126, 234, 0.6)',
                            borderColor: 'rgba(102, 126, 234, 1)',
                            borderWidth: 1
                        }, {
                            label: 'Perfect Prediction Line',
                            data: [
                                { x: Math.min(...actual), y: Math.min(...actual) },
                                { x: Math.max(...actual), y: Math.max(...actual) }
                            ],
                            type: 'line',
                            borderColor: 'red',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: 'Model Performance Visualization'
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Actual Prices ($)'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Predicted Prices ($)'
                                }
                            }
                        }
                    }
                });
            }

            createPredictionForm() {
                const inputsDiv = document.getElementById('predictionInputs');
                
                // Get a sample of important numeric features (limit to top 10 for UI)
                const sampleRow = this.preprocessedData[0];
                const numericFeatures = this.features.filter(feature => 
                    typeof sampleRow[feature] === 'number'
                ).slice(0, 10);

                let formHTML = '<div class="grid">';
                
                numericFeatures.forEach(feature => {
                    const values = this.preprocessedData.map(row => row[feature]).filter(val => !isNaN(val));
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const avg = values.reduce((a, b) => a + b, 0) / values.length;

                    formHTML += `
                        <div class="form-group">
                            <label for="input_${feature}">${feature.replace(/_/g, ' ')}</label>
                            <input type="number" 
                                   id="input_${feature}" 
                                   value="${avg.toFixed(0)}"
                                   min="${min}" 
                                   max="${max}"
                                   step="1">
                        </div>
                    `;
                });

                formHTML += '</div>';
                inputsDiv.innerHTML = formHTML;
            }

            makePrediction() {
                if (!this.model || !this.features) {
                    this.showStatus('Please train the model first', 'error');
                    return;
                }

                try {
                    // Get input values
                    const inputFeatures = new Array(this.features.length).fill(0);
                    
                    this.features.forEach((feature, index) => {
                        const inputElement = document.getElementById(`input_${feature}`);
                        if (inputElement) {
                            inputFeatures[index] = Number(inputElement.value) || 0;
                        } else {
                            // Use average value for features not in form
                            const values = this.preprocessedData.map(row => row[feature]).filter(val => !isNaN(val));
                            inputFeatures[index] = values.reduce((a, b) => a + b, 0) / values.length || 0;
                        }
                    });

                    // Make prediction
                    const predictedPrice = this.predict(inputFeatures);

                    // Display result
                    const resultDiv = document.getElementById('predictionResult');
                    resultDiv.innerHTML = `
                        <div class="status success">
                            <h3>üè° Predicted House Price</h3>
                            <div style="font-size: 2em; font-weight: bold; color: #667eea; margin: 10px 0;">
                                ${predictedPrice.toLocaleString('en-US', {maximumFractionDigits: 0})}
                            </div>
                            <p>Based on the provided features and trained model</p>
                        </div>
                    `;

                } catch (error) {
                    this.showStatus('Error making prediction: ' + error.message, 'error');
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new HousePricePredictor();
        });
    </script>
</body>
</html>